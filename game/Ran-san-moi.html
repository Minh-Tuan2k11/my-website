<!DOCTYPE html>
<html lang="vi">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>üêç R·∫Øn SƒÉn M·ªìi</title>
  <style>
    body {
      background-color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      height: 100vh;
      padding: 10px 0;
      margin: 0;
      color: white;
      font-family: Arial, sans-serif;
    }
    canvas {
      background-color: #111;
      border: 2px solid #0f0;
      max-width: 90vw;
      max-height: 40vh; /* ch·ª´a ch·ªó cho n√∫t */  
    }
    h1 {
      margin-bottom: 10px;
    }
    #startBtn, #toggleColorBtn, .skinBtn, #toggleMazeBtn, #modeToggleBtn {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #0f0;
      color: #000;
      border: none;
      cursor: pointer;
      border-radius: 5px;
    }
    #startBtn:hover, #toggleColorBtn:hover, .skinBtn:hover, #toggleMazeBtn:hover, #modeToggleBtn:hover {
      background-color: #0c0;
    }
    #toggleColorBtn {
      background-color: #ff0;
    }
    .skinBtnsContainer {
      display: flex;
      margin-top: 10px;
    }
    .skinBtn {
      background-color: #444;
      margin: 0 5px;
      color: white;
    }
    .skinBtn:hover {
      background-color: #555;
    }
    #message {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 24px;
      color: #fff;
      background: rgba(0,0,0,0.6);
      padding: 10px 20px;
      border-radius: 10px;
      display: none;
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;      /* kh√≥a scroll */
      touch-action: none;    /* t·∫Øt gesture m·∫∑c ƒë·ªãnh */
    }
  </style>
</head>
<body>
  <h1>üêç R·∫Øn SƒÉn M·ªìi</h1>
  <div id="message">H√£y di chuy·ªÉn ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
  <canvas id="gameCanvas" width="400" height="400"></canvas>
  <button id="startBtn">‚ñ∂ B·∫Øt ƒë·∫ßu / Ch∆°i l·∫°i</button>
  <button id="toggleColorBtn">üîÑ B·∫≠t/T·∫Øt M√†u Ng·∫´u Nhi√™n</button>
  <button id="toggleMazeBtn">üî≤ Ch·∫ø ƒê·ªô M√™ Cung</button>
  <button id="modeToggleBtn">üåÄ Ch·∫ø ƒê·ªô: T∆∞·ªùng Xung Quanh</button>

  <div class="skinBtnsContainer">
    <button class="skinBtn" data-color="#0f0">Xanh l√°</button>
    <button class="skinBtn" data-color="#00f">Xanh d∆∞∆°ng</button>
    <button class="skinBtn" data-color="#f00">ƒê·ªè</button>
    <button class="skinBtn" data-color="#ff0">V√†ng</button>
    <button class="skinBtn" data-color="#fff">Tr·∫Øng</button>
  </div>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const startBtn = document.getElementById("startBtn");
const toggleColorBtn = document.getElementById("toggleColorBtn");
const toggleMazeBtn = document.getElementById("toggleMazeBtn");
const modeToggleBtn = document.getElementById("modeToggleBtn");
const message = document.getElementById("message");

const tileCount = 20;
let gridSize;

/* ================= RESIZE ================= */
function resizeCanvas() {
  const size = Math.min(window.innerWidth, window.innerHeight) - 40;
  canvas.width = size;
  canvas.height = size;
  gridSize = canvas.width / tileCount;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ================= GAME STATE ================= */
let snake, direction, food;
let score = 0;
let gameInterval;
let gameStarted = false;

let snakeColor = "#0f0";
let randomColorEnabled = false;
let mazeMode = false;
let wallMode = false;

/* ================= MAZE ================= */
const mazeWalls = [
  ...Array.from({ length: 18 }, (_, i) => ({ x: i + 1, y: 1 })),
  ...Array.from({ length: 18 }, (_, i) => ({ x: i + 1, y: 18 })),
  ...Array.from({ length: 18 }, (_, i) => ({ x: 1, y: i + 1 })),
  ...Array.from({ length: 18 }, (_, i) => ({ x: 18, y: i + 1 })),
  ...Array.from({ length: 10 }, (_, i) => ({ x: 5, y: i + 4 })),
  ...Array.from({ length: 10 }, (_, i) => ({ x: 14, y: i + 6 })),
  ...Array.from({ length: 6 }, (_, i) => ({ x: i + 7, y: 8 })),
  ...Array.from({ length: 6 }, (_, i) => ({ x: i + 6, y: 13 }))
];

/* ================= UTILS ================= */
function getRandomColor() {
  return "#" + Math.floor(Math.random() * 16777215).toString(16);
}

function isOppositeDirection(newDir) {
  return direction.x + newDir.x === 0 && direction.y + newDir.y === 0;
}

function drawRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
}

/* ================= DRAW ================= */
function drawSnake() {
  snake.forEach((p, i) => {
    const x = p.x * gridSize + 1;
    const y = p.y * gridSize + 1;
    const size = gridSize - 2;
    const radius = i === 0 ? 4 : 2;

    ctx.fillStyle =
      randomColorEnabled && i ? getRandomColor() : snakeColor;

    drawRoundedRect(x, y, size, size, radius);
  });
}

function drawFood() {
  ctx.fillStyle = "#f44";
  ctx.beginPath();
  ctx.arc(
    food.x * gridSize + gridSize / 2,
    food.y * gridSize + gridSize / 2,
    gridSize / 3,
    0,
    Math.PI * 2
  );
  ctx.fill();
}

function drawMaze() {
  ctx.fillStyle = "#0cc";
  mazeWalls.forEach(w =>
    ctx.fillRect(
      w.x * gridSize + 2,
      w.y * gridSize + 2,
      gridSize - 4,
      gridSize - 4
    )
  );
}

/* ================= GAME LOGIC ================= */
function moveSnake() {
  if (!gameStarted) return;

  let nx = snake[0].x + direction.x;
  let ny = snake[0].y + direction.y;

  if (wallMode) {
    if (nx < 0 || ny < 0 || nx >= tileCount || ny >= tileCount)
      return gameOver();
  } else {
    nx = (nx + tileCount) % tileCount;
    ny = (ny + tileCount) % tileCount;
  }

  const head = { x: nx, y: ny };

  if (
    snake.length >= 5 &&
    snake.slice(1).some(s => s.x === head.x && s.y === head.y)
  ) return gameOver();

  if (mazeMode && mazeWalls.some(w => w.x === head.x && w.y === head.y))
    return gameOver();

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y) {
    score++;
    spawnFood();
  } else {
    snake.pop();
  }
}

/* ===== SPAWN FOOD (KH√îNG L·ªñI) ===== */
function spawnFood() {
  let valid = false;
  while (!valid) {
    const x = Math.floor(Math.random() * tileCount);
    const y = Math.floor(Math.random() * tileCount);

    if (x <= 0 || y <= 0 || x >= tileCount - 1 || y >= tileCount - 1) continue;
    if (snake.some(p => p.x === x && p.y === y)) continue;
    if (mazeMode && mazeWalls.some(w => w.x === x && w.y === y)) continue;

    food = { x, y };
    valid = true;
  }
}

function draw() {
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (mazeMode) drawMaze();
  moveSnake();
  drawSnake();
  drawFood();
}

function gameOver() {
  clearInterval(gameInterval);
  alert("ü™¶ Game Over! ƒêi·ªÉm: " + score);
}

/* ================= INPUT ================= */
document.addEventListener("keydown", e => {
  const map = {
    ArrowUp:{x:0,y:-1}, w:{x:0,y:-1},
    ArrowDown:{x:0,y:1}, s:{x:0,y:1},
    ArrowLeft:{x:-1,y:0}, a:{x:-1,y:0},
    ArrowRight:{x:1,y:0}, d:{x:1,y:0}
  };
  const newDir = map[e.key];
  if (!newDir || isOppositeDirection(newDir)) return;

  direction = newDir;
  gameStarted = true;
  message.style.display = "none";
});

/* ===== MOBILE SWIPE (FIX SCROLL) ===== */
let sx = 0, sy = 0;
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  sx = e.touches[0].clientX;
  sy = e.touches[0].clientY;
}, { passive: false });

canvas.addEventListener("touchend", e => {
  e.preventDefault();
  const dx = e.changedTouches[0].clientX - sx;
  const dy = e.changedTouches[0].clientY - sy;

  let newDir =
    Math.abs(dx) > Math.abs(dy)
      ? (dx > 0 ? {x:1,y:0} : {x:-1,y:0})
      : (dy > 0 ? {x:0,y:1} : {x:0,y:-1});

  if (!isOppositeDirection(newDir)) direction = newDir;
  gameStarted = true;
  message.style.display = "none";
}, { passive: false });

/* ================= BUTTONS ================= */
startBtn.onclick = startGame;
toggleColorBtn.onclick = () => randomColorEnabled = !randomColorEnabled;
toggleMazeBtn.onclick = () => mazeMode = !mazeMode;
modeToggleBtn.onclick = () => wallMode = !wallMode;

document.querySelectorAll(".skinBtn").forEach(btn => {
  btn.onclick = () => {
    snakeColor = btn.dataset.color;
    randomColorEnabled = false;
  };
});

/* ================= START ================= */
function startGame() {
  clearInterval(gameInterval);
  snake = [{ x: 10, y: 10 }];
  direction = { x: 0, y: 0 };
  score = 0;
  gameStarted = false;
  spawnFood();
  message.style.display = "block";
  gameInterval = setInterval(draw, 120);
}

startGame();
</script>

</body>
</html>