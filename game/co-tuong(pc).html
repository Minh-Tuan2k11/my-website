<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xiangqi - Chinese Chess | C·ªù T∆∞·ªõng</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* MENU SCREEN */
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3a8a 0%, #7c2d12 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.5s ease-in;
        }

        .menu-screen.hidden {
            display: none;
        }

        .menu-content {
            text-align: center;
            color: white;
            max-width: 500px;
            padding: 40px;
        }

        .menu-title {
            font-size: clamp(2.5rem, 8vw, 4rem);
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        }

        .menu-subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: 50px;
            opacity: 0.9;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-btn {
            padding: 20px 40px;
            font-size: clamp(1rem, 3vw, 1.3rem);
            font-weight: 600;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .menu-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .menu-btn.pvp {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
        }

        .menu-btn.ai {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
        }

        .menu-btn.skins {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            color: white;
        }

        /* SKIN MODAL */
        .skin-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease-in;
        }

        .skin-modal.hidden {
            display: none;
        }

        .skin-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .skin-title {
            font-size: clamp(1.5rem, 4vw, 2rem);
            margin-bottom: 30px;
            text-align: center;
            color: #1f2937;
        }

        .skin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .skin-option {
            padding: 20px;
            border: 3px solid transparent;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
        }

        .skin-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .skin-option.active {
            border-color: #2563eb;
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.4);
        }

        .skin-option.classic {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            color: #92400e;
        }

        .skin-option.modern {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
        }

        .skin-option.wood {
            background: linear-gradient(135deg, #d97706 0%, #92400e 100%);
            color: white;
        }

        .skin-option.dark {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            color: white;
        }

        .skin-close {
            width: 100%;
            padding: 15px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            font-size: 1rem;
        }

        /* GAME CONTAINER */
        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            min-height: 100vh;
            align-items: flex-start;
        }

        .game-container.hidden {
            display: none;
        }

        .left-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            max-width: 350px;
        }

        .main-board {
            flex: 2;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: bold;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #6b7280;
            font-size: clamp(0.8rem, 2vw, 1rem);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: clamp(0.8rem, 2vw, 0.95rem);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn-new {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
        }

        .btn-undo {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
        }

        .btn-undo:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .btn-menu {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            color: white;
        }

        .btn-lang {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .status-bar {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .turn-indicator {
            font-size: clamp(1rem, 3vw, 1.2rem);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .turn-red {
            color: #dc2626;
        }

        .turn-black {
            color: #1f2937;
        }

        .game-status {
            font-weight: 600;
            margin-top: 5px;
        }

        .check-alert {
            color: #dc2626;
            animation: pulse 1s infinite;
        }

        .ai-thinking {
            color: #2563eb;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* MOVE HISTORY */
        .history-section {
            margin-top: 20px;
        }

        .history-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #1f2937;
            text-align: center;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
            background: #f9fafb;
            border-radius: 10px;
            padding: 10px;
        }

        .history-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: white;
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .history-item:nth-child(odd) {
            background: #fef3c7;
        }

        .move-number {
            font-weight: bold;
            color: #6b7280;
        }

        /* BOARD */
        .board-wrapper {
            position: relative;
            padding: 20px;
            border-radius: 15px;
        }

        .board-wrapper.classic {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
        }

        .board-wrapper.modern {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
        }

        .board-wrapper.wood {
            background: linear-gradient(135deg, #92400e 0%, #78350f 100%);
        }

        .board-wrapper.dark {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        }

        .board {
            position: relative;
            aspect-ratio: 9 / 10;
            max-width: 600px;
            margin: 0 auto;
            padding: 5%;
            box-sizing: border-box;
        }

        .board-inner {
            position: relative;
            width: 100%;
            height: 100%;
            border: 3px solid #5b2e0f;
            box-shadow: 
                inset 0 0 0 1px #8b4513,
                0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .board::before {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;

            background:
                /* d·ªçc ‚Äì 9 c·ªôt ‚Üí 8 kho·∫£ng */
                repeating-linear-gradient(
                    to right,
                    transparent 0,
                    transparent calc(100% / 8 - 1px),
                    #5b2e0f calc(100% / 8 - 1px),
                    #5b2e0f calc(100% / 8)
                ),
                /* ngang ‚Äì 10 h√†ng ‚Üí 9 kho·∫£ng */
                repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent calc(100% / 9 - 1px),
                    #5b2e0f calc(100% / 9 - 1px),
                    #5b2e0f calc(100% / 9)
                );
        }
        #board {
            position: relative;
            aspect-ratio: 9 / 10;
            max-width: 600px;
            margin: 0 auto;
            border: 4px solid #5b2e0f;
            box-shadow: 
                0 0 0 2px #8b4513,
                0 8px 16px rgba(0, 0, 0, 0.3);
        }
        .board-inner {
            position: relative;
            width: 100%;
            height: 100%;
            border: 3px solid #5b2e0f;
            box-shadow: 
                inset 0 0 0 1px #8b4513,
                0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .board-bg {
            position: absolute;
            inset: 0;
        }

        .board-lines {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .board-grid {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(10, 1fr);
            z-index: 2;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            user-select: none;
        }
        .board-bg {
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 4px;
        }

        .board-bg.classic {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        }

        .board-bg.modern {
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
        }

        .board-bg.wood {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        }

        .board-bg.dark {
            background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
        }
        
        .board-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .board-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(10, 1fr);
        }
        
        .cell {
            width: 100%;
            height: 100%;
        }

        .river-text {
            position: absolute;
            left: 50%;
            top: 48%;
            z-index: 2;
            transform: translate(-50%, -50%);
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: bold;
            color: #1e40af;
            text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 10;
            letter-spacing: 0.5em;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            user-select: none;
        }

        .cell.selected {
            background: radial-gradient(circle, rgba(254, 240, 138, 0.7) 0%, transparent 70%);
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 4vw, 2rem);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 3px solid;
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #fca5a5, #dc2626);
            color: white;
            border-color: #7f1d1d;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .piece.black {
            background: radial-gradient(circle at 30% 30%, #6b7280, #1f2937);
            color: white;
            border-color: #111827;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .cell:active .piece,
        .cell.selected .piece {
            transform: scale(1.1);
        }
        .cell.can-move::before {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background: radial-gradient(circle, #10b981, #059669);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.6);
            animation: pulse-move 1.5s ease-in-out infinite;
        }

        .cell.can-capture::after {
            content: '';
            position: absolute;
            inset: 8%;
            border-radius: 50%;
            border: 4px solid #dc2626;
            background: radial-gradient(circle, rgba(220, 38, 38, 0.2), transparent);
            box-shadow: 
                0 0 15px rgba(220, 38, 38, 0.6),
                inset 0 0 10px rgba(220, 38, 38, 0.3);
            animation: pulse-capture 1s ease-in-out infinite;
        }

        @keyframes pulse-move {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }

        @keyframes pulse-capture {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.7;
            }
            50% { 
                transform: scale(1.05);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }

            .left-panel {
                max-width: 100%;
                order: 2;
            }

            .main-board {
                order: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- MENU SCREEN -->
    <div class="menu-screen" id="menu-screen">
        <div class="menu-content">
            <h1 class="menu-title">Ë±°Ê£ã</h1>
            <p class="menu-subtitle">C·ªù T∆∞·ªõng - Chinese Chess</p>
            <div class="menu-buttons">
                <button class="menu-btn pvp" onclick="startGame('pvp')">
                    <span id="menu-pvp">üéÆ Play vs Player</span>
                </button>
                <button class="menu-btn ai" onclick="startGame('ai')">
                    <span id="menu-ai">ü§ñ Play vs AI</span>
                </button>
                <button class="menu-btn skins" onclick="showSkinModal()">
                    <span id="menu-skins">üé® Skins</span>
                </button>
            </div>
        </div>
    </div>

    <!-- SKIN MODAL -->
    <div class="skin-modal hidden" id="skin-modal">
        <div class="skin-content">
            <h2 class="skin-title" id="skin-title">Choose Board Theme</h2>
            <div class="skin-grid">
                <div class="skin-option classic active" onclick="selectSkin('classic', event)">
                    <div>üåæ Classic</div>
                </div>
                <div class="skin-option modern" onclick="selectSkin('modern', event)">
                    <div>üíé Modern</div>
                </div>
                <div class="skin-option wood" onclick="selectSkin('wood', event)">
                    <div>üå≥ Wood</div>
                </div>
                <div class="skin-option dark" onclick="selectSkin('dark', event)">
                    <div>üåô Dark</div>
                </div>
            </div>
            <button class="skin-close" onclick="closeSkinModal()">
                <span id="skin-close-btn">Close</span>
            </button>
        </div>
    </div>

    <!-- GAME CONTAINER -->
    <div class="game-container hidden" id="game-container">
        <!-- LEFT PANEL -->
        <div class="left-panel">
            <div class="header">
                <h1 class="title" id="game-title">C·ªù T∆∞·ªõng</h1>
                <p class="subtitle" id="game-subtitle">Chinese Chess</p>
            </div>

            <div class="controls">
                <button class="btn-new" onclick="newGame()">
                    <span id="btn-new-text">V√°n m·ªõi</span>
                </button>
                <button class="btn-undo" id="btn-undo" onclick="undoMove()">
                    <span id="btn-undo-text">Ho√†n t√°c</span>
                </button>
                <button class="btn-menu" onclick="backToMenu()">
                    <span id="btn-menu-text">V·ªÅ Menu</span>
                </button>
                <button class="btn-lang" onclick="toggleLanguage()">
                    <span id="btn-lang-text">EN</span>
                </button>
            </div>

            <div class="status-bar">
                <div class="turn-indicator" id="turn-indicator"></div>
                <div class="game-status" id="game-status"></div>
            </div>

            <div class="history-section">
                <div class="history-title" id="history-title">L·ªãch s·ª≠ n∆∞·ªõc ƒëi</div>
                <div class="history-list" id="history-list">
                    <div style="text-align: center; color: #9ca3af; padding: 20px;">
                        <span id="no-moves">Ch∆∞a c√≥ n∆∞·ªõc ƒëi n√†o</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- MAIN BOARD -->
        <div class="main-board">
            <div class="board-wrapper classic" id="board-wrapper">
                <div class="board">
                    <div class="board-inner">
                        <div class="board-bg classic" id="board-bg"></div>
                        <svg class="board-lines" id="board-lines"></svg>
                        <div class="river-text">Ê•öÊ≤≥ Êº¢Áïå</div>
                        <div class="board-grid" id="board-grid"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
        // Language translations
var LANG = {
    vi: {
        title: "C·ªù T∆∞·ªõng",
        subtitle: "Chinese Chess",
        newGame: "V√°n m·ªõi",
        undo: "Ho√†n t√°c",
        menu: "V·ªÅ Menu",
        langBtn: "EN",
        redTurn: "L∆∞·ª£t ƒê·ªè",
        blackTurn: "L∆∞·ª£t ƒêen",
        check: "Chi·∫øu t∆∞·ªõng!",
        checkmate: "Chi·∫øu b√≠!",
        redWins: "ƒê·ªè th·∫Øng!",
        blackWins: "ƒêen th·∫Øng!",
        aiThinking: "AI ƒëang suy nghƒ©...",
        menuPvP: "üéÆ Ch∆°i 2 ng∆∞·ªùi",
        menuAI: "ü§ñ Ch∆°i v·ªõi AI",
        menuSkins: "üé® Giao di·ªán",
        skinTitle: "Ch·ªçn Giao Di·ªán",
        skinClose: "ƒê√≥ng",
        historyTitle: "L·ªãch s·ª≠ n∆∞·ªõc ƒëi",
        noMoves: "Ch∆∞a c√≥ n∆∞·ªõc ƒëi"
    },
    en: {
        title: "Xiangqi",
        subtitle: "Chinese Chess",
        newGame: "New Game",
        undo: "Undo",
        menu: "Back to Menu",
        langBtn: "VI",
        redTurn: "Red's Turn",
        blackTurn: "Black's Turn",
        check: "Check!",
        checkmate: "Checkmate!",
        redWins: "Red Wins!",
        blackWins: "Black Wins!",
        aiThinking: "AI is thinking...",
        menuPvP: "üéÆ Play vs Player",
        menuAI: "ü§ñ Play vs AI",
        menuSkins: "üé® Skins",
        skinTitle: "Choose Board Theme",
        skinClose: "Close",
        historyTitle: "Move History",
        noMoves: "No moves yet"
    }
};

// Piece symbols
var PIECES = {
    red: {
        king: 'Â∏•',
        advisor: '‰ªï',
        elephant: 'Áõ∏',
        horse: 'ÂÇå',
        rook: '‰ø•',
        cannon: 'ÁÇÆ',
        pawn: 'ÂÖµ'
    },
    black: {
        king: 'Â∞á',
        advisor: 'Â£´',
        elephant: 'Ë±°',
        horse: 'È¶¨',
        rook: 'Ëªä',
        cannon: 'Á†≤',
        pawn: 'Âçí'
    }
};

// Piece values for AI evaluation
var PIECE_VALUES = {
    king: 10000,
    advisor: 20,
    elephant: 20,
    horse: 40,
    rook: 90,
    cannon: 45,
    pawn: 10
};

// Game state variables
var currentLang = localStorage.getItem('xiangqi-lang') || 'vi';
var currentSkin = localStorage.getItem('xiangqi-skin') || 'classic';
var currentSkin = localStorage.getItem('xiangqi-skin');

if (!currentSkin || currentSkin === 'undefined') {
    currentSkin = 'classic';
    localStorage.setItem('xiangqi-skin', currentSkin);
}

var gameMode = 'pvp'; // 'pvp' or 'ai'
var board = [];
var selectedPiece = null;
var validMoves = [];
var currentTurn = 'red';
var gameStatus = 'playing'; // 'playing', 'check', 'checkmate'
var moveHistory = [];
var checkState = null;
var aiThinking = false;

// Game state variables
var currentLang = localStorage.getItem('xiangqi-lang') || 'vi';
var gameMode = 'pvp'; // 'pvp' or 'ai'
var board = [];
var selectedPiece = null;
var validMoves = [];
var currentTurn = 'red';
var gameStatus = 'playing'; // 'playing', 'check', 'checkmate'
var moveHistory = [];
var checkState = null;
var aiThinking = false;

// Copy board for simulation
function copyBoard(b) {
    var newBoard = [];
    for (var i = 0; i < b.length; i++) {
        newBoard[i] = b[i].slice();
    }
    return newBoard;
}

// Initialize board with starting positions
function initBoard() {
    board = [];
    for (var i = 0; i < 10; i++) {
        board[i] = [];
        for (var j = 0; j < 9; j++) {
            board[i][j] = null;
        }
    }

    // Red pieces (bottom)
    board[9][0] = { type: 'rook', side: 'red' };
    board[9][1] = { type: 'horse', side: 'red' };
    board[9][2] = { type: 'elephant', side: 'red' };
    board[9][3] = { type: 'advisor', side: 'red' };
    board[9][4] = { type: 'king', side: 'red' };
    board[9][5] = { type: 'advisor', side: 'red' };
    board[9][6] = { type: 'elephant', side: 'red' };
    board[9][7] = { type: 'horse', side: 'red' };
    board[9][8] = { type: 'rook', side: 'red' };
    board[7][1] = { type: 'cannon', side: 'red' };
    board[7][7] = { type: 'cannon', side: 'red' };
    board[6][0] = { type: 'pawn', side: 'red' };
    board[6][2] = { type: 'pawn', side: 'red' };
    board[6][4] = { type: 'pawn', side: 'red' };
    board[6][6] = { type: 'pawn', side: 'red' };
    board[6][8] = { type: 'pawn', side: 'red' };

    // Black pieces (top)
    board[0][0] = { type: 'rook', side: 'black' };
    board[0][1] = { type: 'horse', side: 'black' };
    board[0][2] = { type: 'elephant', side: 'black' };
    board[0][3] = { type: 'advisor', side: 'black' };
    board[0][4] = { type: 'king', side: 'black' };
    board[0][5] = { type: 'advisor', side: 'black' };
    board[0][6] = { type: 'elephant', side: 'black' };
    board[0][7] = { type: 'horse', side: 'black' };
    board[0][8] = { type: 'rook', side: 'black' };
    board[2][1] = { type: 'cannon', side: 'black' };
    board[2][7] = { type: 'cannon', side: 'black' };
    board[3][0] = { type: 'pawn', side: 'black' };
    board[3][2] = { type: 'pawn', side: 'black' };
    board[3][4] = { type: 'pawn', side: 'black' };
    board[3][6] = { type: 'pawn', side: 'black' };
    board[3][8] = { type: 'pawn', side: 'black' };
}
// Draw board lines with SVG
function drawBoardLines() {
    var svg = document.getElementById('board-lines');
    if (!svg) return;
    
    svg.innerHTML = '';
    svg.setAttribute('viewBox', '0 0 800 900');
    svg.setAttribute('preserveAspectRatio', 'none');
    
    var lineColor = '#5b2e0f';
    var lineWidth = 2;
    
    // Calculate positions (pieces sit on intersections)
    var leftMargin = 50;
    var topMargin = 50;
    var rightMargin = 50;
    var bottomMargin = 50;
    var boardWidth = 800 - leftMargin - rightMargin;
    var boardHeight = 900 - topMargin - bottomMargin;
    var cellWidth = boardWidth / 8;  // 8 spaces, 9 lines
    var cellHeight = boardHeight / 9; // 9 spaces, 10 lines
    
    // Draw horizontal lines
    for (var i = 0; i < 10; i++) {
        var y = topMargin + i * cellHeight;
        var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        
        // River gap - don't connect middle lines
        if (i === 0 || i === 9) {
            // Full lines for top and bottom
            line.setAttribute('x1', leftMargin);
            line.setAttribute('x2', leftMargin + boardWidth);
        } else {
            // Split lines for others
            line.setAttribute('x1', leftMargin);
            line.setAttribute('x2', leftMargin + boardWidth);
        }
        
        line.setAttribute('y1', y);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', lineColor);
        line.setAttribute('stroke-width', lineWidth);
        svg.appendChild(line);
    }
    
    // Draw vertical lines
    for (var i = 0; i < 9; i++) {
        var x = leftMargin + i * cellWidth;
        
        // Edge lines go full height
        if (i === 0 || i === 8) {
            var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x);
            line.setAttribute('x2', x);
            line.setAttribute('y1', topMargin);
            line.setAttribute('y2', topMargin + boardHeight);
            line.setAttribute('stroke', lineColor);
            line.setAttribute('stroke-width', lineWidth);
            svg.appendChild(line);
        } else {
            // Other lines split at river
            // Top half
            var line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', x);
            line1.setAttribute('x2', x);
            line1.setAttribute('y1', topMargin);
            line1.setAttribute('y2', topMargin + 4 * cellHeight);
            line1.setAttribute('stroke', lineColor);
            line1.setAttribute('stroke-width', lineWidth);
            svg.appendChild(line1);
            
            // Bottom half
            var line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', x);
            line2.setAttribute('x2', x);
            line2.setAttribute('y1', topMargin + 5 * cellHeight);
            line2.setAttribute('y2', topMargin + boardHeight);
            line2.setAttribute('stroke', lineColor);
            line2.setAttribute('stroke-width', lineWidth);
            svg.appendChild(line2);
        }
    }
    
    // Draw palace diagonals - Black (top)
    var palaceLines = [
        // Black palace
        [leftMargin + 3 * cellWidth, topMargin, leftMargin + 5 * cellWidth, topMargin + 2 * cellHeight],
        [leftMargin + 5 * cellWidth, topMargin, leftMargin + 3 * cellWidth, topMargin + 2 * cellHeight],
        // Red palace
        [leftMargin + 3 * cellWidth, topMargin + 7 * cellHeight, leftMargin + 5 * cellWidth, topMargin + 9 * cellHeight],
        [leftMargin + 5 * cellWidth, topMargin + 7 * cellHeight, leftMargin + 3 * cellWidth, topMargin + 9 * cellHeight]
    ];
    
    for (var i = 0; i < palaceLines.length; i++) {
        var coords = palaceLines[i];
        var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', coords[0]);
        line.setAttribute('y1', coords[1]);
        line.setAttribute('x2', coords[2]);
        line.setAttribute('y2', coords[3]);
        line.setAttribute('stroke', lineColor);
        line.setAttribute('stroke-width', lineWidth);
        svg.appendChild(line);
    }
}
// Get all valid moves for a piece
function getValidMoves(row, col, piece, testBoard) {
    if (!testBoard) testBoard = board;
    var moves = [];
    var type = piece.type;
    var side = piece.side;

    if (type === 'king') {
        var palaceRows = side === 'red' ? [7, 8, 9] : [0, 1, 2];
        var palaceCols = [3, 4, 5];
        var directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (var i = 0; i < directions.length; i++) {
            var dr = directions[i][0];
            var dc = directions[i][1];
            var newRow = row + dr;
            var newCol = col + dc;
            if (palaceRows.indexOf(newRow) !== -1 && palaceCols.indexOf(newCol) !== -1) {
                var target = testBoard[newRow][newCol];
                if (!target || target.side !== side) {
                    moves.push([newRow, newCol]);
                }
            }
        }
        // Flying general rule
        var step = side === 'red' ? -1 : 1;
        var r = row + step;
        while (r >= 0 && r < 10) {
            var p = testBoard[r][col];
            if (p) {
                if (p.type === 'king' && p.side !== side) {
                    moves.push([r, col]);
                }
                break;
            }
            r += step;
        }
    } else if (type === 'advisor') {
        var advPalaceRows = side === 'red' ? [7, 8, 9] : [0, 1, 2];
        var advPalaceCols = [3, 4, 5];
        var advDirections = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        for (var i = 0; i < advDirections.length; i++) {
            var dr = advDirections[i][0];
            var dc = advDirections[i][1];
            var newRow = row + dr;
            var newCol = col + dc;
            if (advPalaceRows.indexOf(newRow) !== -1 && advPalaceCols.indexOf(newCol) !== -1) {
                var target = testBoard[newRow][newCol];
                if (!target || target.side !== side) {
                    moves.push([newRow, newCol]);
                }
            }
        }
    } else if (type === 'elephant') {
        var elephantRows = side === 'red' ? [5, 6, 7, 8, 9] : [0, 1, 2, 3, 4];
        var eleDirections = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
        for (var i = 0; i < eleDirections.length; i++) {
            var dr = eleDirections[i][0];
            var dc = eleDirections[i][1];
            var newRow = row + dr;
            var newCol = col + dc;
            var blockRow = row + Math.floor(dr / 2);
            var blockCol = col + Math.floor(dc / 2);
            if (elephantRows.indexOf(newRow) !== -1 && newCol >= 0 && newCol < 9) {
                if (!testBoard[blockRow][blockCol]) {
                    var target = testBoard[newRow][newCol];
                    if (!target || target.side !== side) {
                        moves.push([newRow, newCol]);
                    }
                }
            }
        }
    } else if (type === 'horse') {
        var horseDirections = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
        for (var i = 0; i < horseDirections.length; i++) {
            var dr = horseDirections[i][0];
            var dc = horseDirections[i][1];
            var newRow = row + dr;
            var newCol = col + dc;
            var blockRow = row + (Math.abs(dr) === 2 ? Math.floor(dr / 2) : 0);
            var blockCol = col + (Math.abs(dc) === 2 ? Math.floor(dc / 2) : 0);
            if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 9) {
                if (!testBoard[blockRow][blockCol]) {
                    var target = testBoard[newRow][newCol];
                    if (!target || target.side !== side) {
                        moves.push([newRow, newCol]);
                    }
                }
            }
        }
    } else if (type === 'rook') {
        var rookDirections = [[1, 0], [-1, 0], [0, 1], [0, -1]];
        for (var i = 0; i < rookDirections.length; i++) {
            var dr = rookDirections[i][0];
            var dc = rookDirections[i][1];
            var newRow = row + dr;
            var newCol = col + dc;
            while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 9) {
                var target = testBoard[newRow][newCol];
                if (!target) {
                    moves.push([newRow, newCol]);
                } else {
                    if (target.side !== side) {
                        moves.push([newRow, newCol]);
                    }
                    break;
                }
                newRow += dr;
                newCol += dc;
            }
        }
    } else if (type === 'cannon') {
        var cannonDirections = [[1, 0], [-1, 0], [0, 1], [0, -1]];
        for (var i = 0; i < cannonDirections.length; i++) {
            var dr = cannonDirections[i][0];
            var dc = cannonDirections[i][1];
            var newRow = row + dr;
            var newCol = col + dc;
            var jumped = false;
            while (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 9) {
                var target = testBoard[newRow][newCol];
                if (!jumped) {
                    if (!target) {
                        moves.push([newRow, newCol]);
                    } else {
                        jumped = true;
                    }
                } else {
                    if (target) {
                        if (target.side !== side) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                }
                newRow += dr;
                newCol += dc;
            }
        }
    } else if (type === 'pawn') {
        var forward = side === 'red' ? -1 : 1;
        var crossedRiver = side === 'red' ? row < 5 : row > 4;
        var fwdRow = row + forward;
        if (fwdRow >= 0 && fwdRow < 10) {
            var target = testBoard[fwdRow][col];
            if (!target || target.side !== side) {
                moves.push([fwdRow, col]);
            }
        }
        if (crossedRiver) {
            var sideDirections = [[0, 1], [0, -1]];
            for (var i = 0; i < sideDirections.length; i++) {
                var dr = sideDirections[i][0];
                var dc = sideDirections[i][1];
                var newRow = row + dr;
                var newCol = col + dc;
                if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 9) {
                    var target = testBoard[newRow][newCol];
                    if (!target || target.side !== side) {
                        moves.push([newRow, newCol]);
                    }
                }
            }
        }
    }
    return moves;
}

// Check if kings are facing each other
function kingsFacing(testBoard) {
    if (!testBoard) testBoard = board;
    var redKing = null;
    var blackKing = null;
    for (var r = 0; r < 10; r++) {
        for (var c = 0; c < 9; c++) {
            var p = testBoard[r][c];
            if (p && p.type === 'king') {
                if (p.side === 'red') redKing = [r, c];
                else if (p.side === 'black') blackKing = [r, c];
            }
        }
    }
    if (!redKing || !blackKing) return false;
    if (redKing[1] !== blackKing[1]) return false;
    var col = redKing[1];
    var start = Math.min(redKing[0], blackKing[0]) + 1;
    var end = Math.max(redKing[0], blackKing[0]);
    for (var i = start; i < end; i++) {
        if (testBoard[i][col]) return false;
    }
    return true;
}

// Check if a side is in check
function isInCheck(side, testBoard) {
    if (!testBoard) testBoard = board;

    // sau khi testBoard ƒë√£ ch·∫Øc ch·∫Øn t·ªìn t·∫°i
    if (kingsFacing(testBoard)) {
        return true;
    }

    var kingPos = null;

    for (var r = 0; r < 10; r++) {
        for (var c = 0; c < 9; c++) {
            var cell = testBoard[r][c];
            if (cell && cell.type === 'king' && cell.side === side) {
                kingPos = [r, c];
                break;
            }
        }
        if (kingPos) break;
    }

    if (!kingPos) return false;

    for (var r = 0; r < 10; r++) {
        for (var c = 0; c < 9; c++) {
            var piece = testBoard[r][c];
            if (piece && piece.side !== side) {
                var moves = getValidMoves(r, c, piece, testBoard);
                for (var i = 0; i < moves.length; i++) {
                    if (
                        moves[i][0] === kingPos[0] &&
                        moves[i][1] === kingPos[1]
                    ) {
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

// Check if a side is in checkmate
function isCheckmate(side) {
    for (var r = 0; r < 10; r++) {
        for (var c = 0; c < 9; c++) {
            var piece = board[r][c];
            if (piece && piece.side === side) {
                var moves = getValidMoves(r, c, piece);
                for (var i = 0; i < moves.length; i++) {
                    var mr = moves[i][0];
                    var mc = moves[i][1];
                    var testBoard = copyBoard(board);
                    testBoard[mr][mc] = testBoard[r][c];
                    testBoard[r][c] = null;
                    if (!isInCheck(side, testBoard)) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
}

// Evaluate board position
function evaluateBoard(testBoard) {
    var score = 0;
    for (var r = 0; r < 10; r++) {
        for (var c = 0; c < 9; c++) {
            var piece = testBoard[r][c];
            if (piece) {
                var value = PIECE_VALUES[piece.type];
                if (piece.side === 'black') score += value;
                else score -= value;
            }
        }
    }
    return score;
}

// Get all legal moves for a side
function getAllMoves(side, testBoard) {
    var allMoves = [];
    for (var r = 0; r < 10; r++) {
        for (var c = 0; c < 9; c++) {
            var piece = testBoard[r][c];
            if (piece && piece.side === side) {
                var moves = getValidMoves(r, c, piece, testBoard);
                for (var i = 0; i < moves.length; i++) {
                    var newBoard = copyBoard(testBoard);
                    newBoard[moves[i][0]][moves[i][1]] = newBoard[r][c];
                    newBoard[r][c] = null;
                    if (!isInCheck(side, newBoard)) {
                        allMoves.push({
                            from: [r, c],
                            to: moves[i],
                            board: newBoard
                        });
                    }
                }
            }
        }
    }
    return allMoves;
}

// Minimax algorithm with alpha-beta pruning
function minimax(depth, isMaximizing, alpha, beta, testBoard) {
    if (depth === 0) return evaluateBoard(testBoard);
    var side = isMaximizing ? 'black' : 'red';
    var moves = getAllMoves(side, testBoard);
    if (moves.length === 0) {
        if (isInCheck(side, testBoard)) {
            return isMaximizing ? -100000 : 100000;
        }
        return 0;
    }
    if (isMaximizing) {
        var maxEval = -999999;
        for (var i = 0; i < moves.length; i++) {
            var evalScore = minimax(depth - 1, false, alpha, beta, moves[i].board);
            if (evalScore > maxEval) maxEval = evalScore;
            if (evalScore > alpha) alpha = evalScore;
            if (beta <= alpha) break;
        }
        return maxEval;
    } else {
        var minEval = 999999;
        for (var i = 0; i < moves.length; i++) {
            var evalScore = minimax(depth - 1, true, alpha, beta, moves[i].board);
            if (evalScore < minEval) minEval = evalScore;
            if (evalScore < beta) beta = evalScore;
            if (beta <= alpha) break;
        }
        return minEval;
    }
}

// Get best move for AI
function getAIMove() {
    var moves = getAllMoves('black', board);
    if (moves.length === 0) return null;
    var bestMove = null;
    var bestScore = -999999;
    for (var i = 0; i < moves.length; i++) {
        var score = minimax(2, false, -999999, 999999, moves[i].board);
        if (score > bestScore) {
            bestScore = score;
            bestMove = moves[i];
        }
    }
    return bestMove;
}

// Execute AI move
function makeAIMove() {
    if (aiThinking || gameStatus !== 'playing' || currentTurn !== 'black' || gameMode !== 'ai') return;
    aiThinking = true;
    updateStatus();
    setTimeout(function() {
        var aiMove = getAIMove();
        if (aiMove) {
            var fromRow = aiMove.from[0];
            var fromCol = aiMove.from[1];
            var toRow = aiMove.to[0];
            var toCol = aiMove.to[1];
            moveHistory.push({
                from: [fromRow, fromCol],
                to: [toRow, toCol],
                piece: board[fromRow][fromCol],
                captured: board[toRow][toCol]
            });
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            currentTurn = 'red';
            var inCheck = isInCheck(currentTurn);
            if (inCheck) {
                checkState = currentTurn;
                if (isCheckmate(currentTurn)) {
                    gameStatus = 'checkmate';
                }
            } else {
                checkState = null;
            }
        }
        aiThinking = false;
        renderBoard();
        updateStatus();
        updateHistory();
    }, 500);
}

// Render the board
function renderBoard() {
    drawBoardLines();

    var grid = document.getElementById('board-grid');
    grid.innerHTML = '';
    for (var row = 0; row < 10; row++) {
        for (var col = 0; col < 9; col++) {
            var cell = document.createElement('div');
            cell.className = 'cell';
            cell.setAttribute('data-row', row);
            cell.setAttribute('data-col', col);
            
            var isSelected = selectedPiece && selectedPiece[0] === row && selectedPiece[1] === col;
            if (isSelected) cell.classList.add('selected');
            
            var isValidMove = false;
            for (var i = 0; i < validMoves.length; i++) {
                if (validMoves[i][0] === row && validMoves[i][1] === col) {
                    isValidMove = true;
                    break;
                }
            }
            if (isValidMove) {
                if (board[row][col]) {
                    cell.classList.add('can-capture');
                } else {
                    cell.classList.add('can-move');
                }
            }
            
            var piece = board[row][col];
            if (piece) {
                var pieceEl = document.createElement('div');
                pieceEl.className = 'piece ' + piece.side;
                pieceEl.textContent = PIECES[piece.side][piece.type];
                cell.appendChild(pieceEl);
            }
            
            cell.onclick = (function(r, c) {
                return function() { handleCellClick(r, c); };
            })(row, col);
            grid.appendChild(cell);
        }
    }
}

// Update status display
function updateStatus() {
    var t = LANG[currentLang];
    var turnIndicator = document.getElementById('turn-indicator');
    var gameStatusEl = document.getElementById('game-status');
    
    turnIndicator.textContent = currentTurn === 'red' ? t.redTurn : t.blackTurn;
    turnIndicator.className = 'turn-indicator turn-' + currentTurn;
    
    if (aiThinking) {
        gameStatusEl.innerHTML = '<div class="ai-thinking">' + t.aiThinking + '</div>';
    } else if (checkState && gameStatus === 'playing') {
        gameStatusEl.innerHTML = '<div class="check-alert">' + t.check + '</div>';
    } else if (gameStatus === 'checkmate') {
        var winner = checkState === 'red' ? t.blackWins : t.redWins;
        gameStatusEl.innerHTML = '<div>' + winner + ' - ' + t.checkmate + '</div>';
    } else {
        gameStatusEl.innerHTML = '';
    }
    
    document.getElementById('btn-undo').disabled = moveHistory.length === 0;
}

// Update move history display
function updateHistory() {
    var t = LANG[currentLang];
    var list = document.getElementById('history-list');
    
    if (moveHistory.length === 0) {
        list.innerHTML = '<div style="text-align:center;color:#9ca3af;padding:20px">' +
            '<span>' + t.noMoves + '</span></div>';
        return;
    }
    
    list.innerHTML = '';
    for (var i = 0; i < moveHistory.length; i++) {
        var move = moveHistory[i];
        var item = document.createElement('div');
        item.className = 'history-item';
        
        var moveNum = document.createElement('span');
        moveNum.className = 'move-number';
        moveNum.textContent = (i + 1) + '.';
        
        var moveText = document.createElement('span');
        var fromCoord = String.fromCharCode(97 + move.from[1]) + (10 - move.from[0]);
        var toCoord = String.fromCharCode(97 + move.to[1]) + (10 - move.to[0]);
        var pieceSymbol = PIECES[move.piece.side][move.piece.type];
        moveText.textContent = pieceSymbol + ' ' + fromCoord + ' ‚Üí ' + toCoord;
        
        item.appendChild(moveNum);
        item.appendChild(moveText);
        list.appendChild(item);
    }
    
    // Scroll to bottom
    list.scrollTop = list.scrollHeight;
}

// Update language in UI
function updateLanguage() {
    var t = LANG[currentLang];

    var el;

    // Game screen
    el = document.getElementById('game-title');
    if (el) el.textContent = t.title;

    el = document.getElementById('game-subtitle');
    if (el) el.textContent = t.subtitle;

    el = document.getElementById('btn-new-text');
    if (el) el.textContent = t.newGame;

    el = document.getElementById('btn-undo-text');
    if (el) el.textContent = t.undo;

    el = document.getElementById('btn-menu-text');
    if (el) el.textContent = t.menu;

    el = document.getElementById('btn-lang-text');
    if (el) el.textContent = t.langBtn;

    el = document.getElementById('history-title');
    if (el) el.textContent = t.historyTitle;

    // Menu screen
    el = document.getElementById('menu-pvp');
    if (el) el.textContent = t.menuPvP;

    el = document.getElementById('menu-ai');
    if (el) el.textContent = t.menuAI;

    el = document.getElementById('menu-skins');
    if (el) el.textContent = t.menuSkins;

    // Skin modal
    el = document.getElementById('skin-title');
    if (el) el.textContent = t.skinTitle;

    el = document.getElementById('skin-close-btn');
    if (el) el.textContent = t.skinClose;

    // Update status and history
    updateStatus();
    updateHistory();
}
function clearHighlights() {
    var cells = document.querySelectorAll('.cell');
    for (var i = 0; i < cells.length; i++) {
        cells[i].classList.remove('can-move');
        cells[i].classList.remove('can-capture');
        cells[i].classList.remove('selected');
    }
}

function highlightMoves(row, col) {
    clearHighlights();

    var piece = board[row][col];
    if (!piece) return;

    var cell = document.querySelector(
        '.cell[data-row="' + row + '"][data-col="' + col + '"]'
    );
    if (cell) {
        cell.classList.add('selected');
    }

    var moves = getValidMoves(row, col, piece);

    for (var i = 0; i < moves.length; i++) {
        var r = moves[i][0];
        var c = moves[i][1];

        var targetCell = document.querySelector(
            '.cell[data-row="' + r + '"][data-col="' + c + '"]'
        );

        if (!targetCell) continue;

        if (board[r][c] && board[r][c].side !== piece.side) {
            targetCell.classList.add('can-capture');
        } else {
            targetCell.classList.add('can-move');
        }
    }
}

// Handle cell click
function handleCellClick(row, col) {
    if (gameStatus !== 'playing' || aiThinking) return;
    if (gameMode === 'ai' && currentTurn === 'black') return;

    var piece = board[row][col];

    // =============================
    // TR∆Ø·ªúNG H·ª¢P: ƒê√É CH·ªåN QU√ÇN
    // =============================
    if (selectedPiece) {
        var fromRow = selectedPiece[0];
        var fromCol = selectedPiece[1];

        // Ki·ªÉm tra √¥ click c√≥ n·∫±m trong validMoves kh√¥ng
        var isValid = false;
        for (var i = 0; i < validMoves.length; i++) {
            if (validMoves[i][0] === row && validMoves[i][1] === col) {
                isValid = true;
                break;
            }
        }

        // --------------------------------
        // TH·ª∞C HI·ªÜN N∆Ø·ªöC ƒêI H·ª¢P L·ªÜ
        // --------------------------------
        if (isValid) {
            var testBoard = copyBoard(board);
            testBoard[row][col] = testBoard[fromRow][fromCol];
            testBoard[fromRow][fromCol] = null;

            // Kh√¥ng ƒë∆∞·ª£c t·ª± chi·∫øu ho·∫∑c ƒë·ªÉ hai vua ƒë·ªëi m·∫∑t
            if (isInCheck(currentTurn, testBoard) || kingsFacing(testBoard)) {
                return;
            }

            // L∆∞u l·ªãch s·ª≠
            moveHistory.push({
                from: [fromRow, fromCol],
                to: [row, col],
                piece: board[fromRow][fromCol],
                captured: board[row][col]
            });

            // C·∫≠p nh·∫≠t b√†n c·ªù th·∫≠t
            board = testBoard;
            currentTurn = currentTurn === 'red' ? 'black' : 'red';

            // Ki·ªÉm tra chi·∫øu / chi·∫øu b√≠
            if (isInCheck(currentTurn)) {
                checkState = currentTurn;
                if (isCheckmate(currentTurn)) {
                    gameStatus = 'checkmate';
                }
            } else {
                checkState = null;
            }

            // Reset ch·ªçn qu√¢n & highlight
            selectedPiece = null;
            validMoves = [];
            clearHighlights();

            renderBoard();
            updateStatus();
            updateHistory();

            // AI ƒëi
            if (
                gameMode === 'ai' &&
                currentTurn === 'black' &&
                gameStatus === 'playing'
            ) {
                makeAIMove();
            }
            return;
        }

        // --------------------------------
        // CLICK QU√ÇN KH√ÅC C√ôNG M√ÄU ‚Üí ƒê·ªîI CH·ªåN
        // --------------------------------
        if (piece && piece.side === currentTurn) {
            selectedPiece = [row, col];
            validMoves = getValidMoves(row, col, piece);
            highlightMoves(row, col);
            return;
        }

        // --------------------------------
        // CLICK √î KH√îNG H·ª¢P L·ªÜ ‚Üí B·ªé CH·ªåN
        // --------------------------------
        selectedPiece = null;
        validMoves = [];
        clearHighlights();
        return;
    }

    // =============================
    // TR∆Ø·ªúNG H·ª¢P: CH∆ØA CH·ªåN QU√ÇN
    // =============================
    if (piece && piece.side === currentTurn) {
        selectedPiece = [row, col];
        validMoves = getValidMoves(row, col, piece);
        highlightMoves(row, col);
    }
}

// Start new game
function newGame() {
    initBoard();
    selectedPiece = null;
    validMoves = [];
    currentTurn = 'red';
    gameStatus = 'playing';
    moveHistory = [];
    checkState = null;
    aiThinking = false;
    renderBoard();
    updateStatus();
    updateHistory();
}

// Undo last move
function undoMove() {
    if (moveHistory.length === 0) return;
    
    var lastMove = moveHistory.pop();
    board[lastMove.from[0]][lastMove.from[1]] = lastMove.piece;
    board[lastMove.to[0]][lastMove.to[1]] = lastMove.captured;
    
    if (gameMode === 'ai' && moveHistory.length > 0) {
        var lastMove2 = moveHistory.pop();
        board[lastMove2.from[0]][lastMove2.from[1]] = lastMove2.piece;
        board[lastMove2.to[0]][lastMove2.to[1]] = lastMove2.captured;
    }
    
    currentTurn = currentTurn === 'red' ? 'black' : 'red';
    selectedPiece = null;
    validMoves = [];
    checkState = null;
    gameStatus = 'playing';
    aiThinking = false;
    renderBoard();
    updateStatus();
    updateHistory();
}

// Toggle language
function toggleLanguage() {
    currentLang = currentLang === 'vi' ? 'en' : 'vi';
    localStorage.setItem('xiangqi-lang', currentLang);
    updateLanguage();
}

// Start game from menu
function startGame(mode) {
    gameMode = mode;
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('game-container').classList.remove('hidden');
    newGame();
}

// Back to menu
function backToMenu() {
    document.getElementById('game-container').classList.add('hidden');
    document.getElementById('menu-screen').classList.remove('hidden');
}

// Show skin modal
function showSkinModal() {
    document.getElementById('skin-modal').classList.remove('hidden');
}

// Close skin modal
function closeSkinModal() {
    document.getElementById('skin-modal').classList.add('hidden');
}

// Select skin
function selectSkin(skin, event) {
    // ‚õî Ch·∫∑n d·ªØ li·ªáu sai
    if (!skin) return;

    currentSkin = skin;
    localStorage.setItem('xiangqi-skin', skin);

    // B·ªè active c≈©
    var options = document.querySelectorAll('.skin-option');
    for (var i = 0; i < options.length; i++) {
        options[i].classList.remove('active');
    }

    // Active skin ƒë∆∞·ª£c click (ch·ªâ khi c√≥ event)
    if (event && event.target) {
        var option = event.target.closest('.skin-option');
        if (option) option.classList.add('active');
    }

    // √Åp d·ª•ng skin
    var boardWrapper = document.getElementById('board-wrapper');
    if (boardWrapper) {
        boardWrapper.className = 'board-wrapper ' + skin;
    }

    var boardBg = document.getElementById('board-bg');
    if (boardBg) {
        boardBg.className = 'board-bg ' + skin;
    }
}


// Initialize game on page load
(function() {
    // Load saved skin
    selectSkin(currentSkin);
    
    // Update language
    updateLanguage();
    
    // Set initial skin selection
    var skinOptions = document.querySelectorAll('.skin-option');
    for (var i = 0; i < skinOptions.length; i++) {
        skinOptions[i].classList.remove('active');
        if (skinOptions[i].classList.contains(currentSkin)) {
            skinOptions[i].classList.add('active');
        }
    }
})();

(function initGameUI() {
    // Apply saved skin
    selectSkin(currentSkin);

    // Update active skin in menu
    var skinOptions = document.querySelectorAll('.skin-option');
    for (var i = 0; i < skinOptions.length; i++) {
        skinOptions[i].classList.remove('active');
        if (skinOptions[i].classList.contains(currentSkin)) {
            skinOptions[i].classList.add('active');
        }
    }

    // Language
    updateLanguage();
    
    // Draw board lines
    drawBoardLines(); // Add this line
})();

</script>